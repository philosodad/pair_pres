%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Paul at 2013-07-30 16:03:18 -0400 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{1553595,
	Abstract = {Pair programming is a programming technique in which two programmers use one computer to work together on the same task. There is an ongoing debate over the value of pair programming in software development. The current body of knowledge in this area is scattered and unorganized. Review shows that most of the results have been obtained from experimental studies in university settings. Few, if any, empirical studies exist, where pair programming has been systematically under scrutiny in real software development projects. Thus, its proposed benefits remain currently without solid empirical evidence. This paper reports results from four software development projects where the impact of pair programming on software product quality was studied. Our empirical findings appear to offer contrasting results regarding some of the claimed benefits of pair programming. They indicate that pair programming may not necessarily provide as extensive quality benefits as suggested in literature, and on the other hand, does not result in consistently superior productivity when compared to solo programming.},
	Author = {Hulkko, H. and Abrahamsson, P.},
	Booktitle = {Software Engineering, 2005. ICSE 2005. Proceedings. 27th International Conference on},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1109/ICSE.2005.1553595},
	Keywords = {parallel programming;software quality;agile software development;empirical software engineering;extreme programming;pair programming;software quality;Anthropometry;Computer aided software engineering;Navigation;Permission;Productivity;Programming profession;Scattering;Software engineering;Software quality;Solids},
	Pages = {495-504},
	Title = {A multiple case study on the impact of pair programming on product quality},
	Year = {2005},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSE.2005.1553595},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJS4uLy4uL3Jlc2VhcmNoX3BhcGVycy9wNDk1LWh1bGtrby5wZGbSFwsYGVdOUy5kYXRhTxEBpgAAAAABpgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAyuu2AEgrAAABOI2cD3A0OTUtaHVsa2tvLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE50MLNbE2BAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAA9yZXNlYXJjaF9wYXBlcnMAABAACAAAyuv8UAAAABEACAAAzWyFwQAAAAEAEAE4jZwBOIyrATgm0wAAwEMAAgBDTWFjaW50b3NoIEhEOlVzZXJzOgBwYXVsOgBEcm9wYm94OgByZXNlYXJjaF9wYXBlcnM6AHA0OTUtaHVsa2tvLnBkZgAADgAgAA8AcAA0ADkANQAtAGgAdQBsAGsAawBvAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAyVXNlcnMvcGF1bC9Ecm9wYm94L3Jlc2VhcmNoX3BhcGVycy9wNDk1LWh1bGtrby5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC2ALsAwwJtAm8CdAJ/AogClgKaAqECqgKvArwCvwLRAtQC2QAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb}}

@inproceedings{5315998,
	Abstract = {In this paper we present a study on how pair programming (PP) facilitates the introduction of new developers (novices) in a team. Data has been collected non-invasively on how people paired in an industrial team of developers for 10 months; during such time novices joined the team. We focused on spontaneous PP, that is, on PP occurring when developers think it is most effective. Social network analysis techniques are used to analyze developers interactions and infer possible conclusions. It appears that initially PP is used to initiate novices, then it is drastically reduced to be resumed eventually when novices ldquofeelrdquo they have reached a significant level of maturity in the team. These phases are coherent with available works on group development and confirm existing findings on the importance of PP in the introduction of novices in teams, and, more generally, on team dynamics.},
	Author = {Fronza, I. and Sillitti, A. and Succi, G.},
	Booktitle = {Empirical Software Engineering and Measurement, 2009. ESEM 2009. 3rd International Symposium on},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1109/ESEM.2009.5315998},
	Issn = {1938-6451},
	Keywords = {software quality;systems analysis;novices integration;pair programming;social network analysis techniques;Computer errors;Navigation;Performance analysis;Productivity;Programming profession;Social network services;Software engineering;Software measurement;Software quality;Writing},
	Pages = {225-235},
	Title = {An interpretation of the results of the analysis of pair programming during novices integration in a team},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ESEM.2009.5315998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uLy4uL3Jlc2VhcmNoX3BhcGVycy8wNTMxNTk5OC5wZGbSFwsYGVdOUy5kYXRhTxEBmgAAAAABmgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAyuu2AEgrAAABOI2cDDA1MzE1OTk4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE50XHNbE/MAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAA9yZXNlYXJjaF9wYXBlcnMAABAACAAAyuv8UAAAABEACAAAzWyIDAAAAAEAEAE4jZwBOIyrATgm0wAAwEMAAgBATWFjaW50b3NoIEhEOlVzZXJzOgBwYXVsOgBEcm9wYm94OgByZXNlYXJjaF9wYXBlcnM6ADA1MzE1OTk4LnBkZgAOABoADAAwADUAMwAxADUAOQA5ADgALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAC9Vc2Vycy9wYXVsL0Ryb3Bib3gvcmVzZWFyY2hfcGFwZXJzLzA1MzE1OTk4LnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJeAmACZQJwAnkChwKLApICmwKgAq0CsALCAsUCygAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM}}

@article{4052584,
	Abstract = {A total of 295 junior, intermediate, and senior professional Java consultants (99 individuals and 98 pairs) from 29 international consultancy companies in Norway, Sweden, and the UK were hired for one day to participate in a controlled experiment on pair programming. The subjects used professional Java tools to perform several change tasks on two alternative Java systems with different degrees of complexity. The results of this experiment do not support the hypotheses that pair programming in general reduces the time required to solve the tasks correctly or increases the proportion of correct solutions. On the other hand, there is a significant 84 percent increase in effort to perform the tasks correctly. However, on the more complex system, the pair programmers had a 48 percent increase in the proportion of correct solutions but no significant differences in the time taken to solve the tasks correctly. For the simpler system, there was a 20 percent decrease in time taken but no significant differences in correctness. However, the moderating effect of system complexity depends on the programmer expertise of the subjects. The observed benefits of pair programming in terms of correctness on the complex system apply mainly to juniors, whereas the reductions in duration to perform the tasks correctly on the simple system apply mainly to intermediates and seniors. It is possible that the benefits of pair programming will exceed the results obtained in this experiment for larger, more complex tasks and if the pair programmers have a chance to work together over a longer period of time},
	Author = {Arisholm, E. and Gallis, H. and Dyba, T. and Sjoberg, D.I.K.},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1109/TSE.2007.17},
	Issn = {0098-5589},
	Journal = {Software Engineering, IEEE Transactions on},
	Keywords = {Java;object-oriented programming;task analysis;team working;Java;pair programming;programmer expertise;system complexity;Computer industry;Cost function;Helium;Java;Keyboards;Power measurement;Programming profession;Software engineering;Software maintenance;Time measurement;Empirical software engineering;control styles;design principles;extreme programming;object-oriented programming;pair programming;quasi-experiment.;software maintainability},
	Number = {2},
	Pages = {65-86},
	Title = {Evaluating Pair Programming with Respect to System Complexity and Programmer Expertise},
	Volume = {33},
	Year = {2007},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/TSE.2007.17},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uLy4uL3Jlc2VhcmNoX3BhcGVycy8wNDA1MjU4NC5wZGbSFwsYGVdOUy5kYXRhTxEBmgAAAAABmgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAyuu2AEgrAAABOI2cDDA0MDUyNTg0LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE50nDNbEqkAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAA9yZXNlYXJjaF9wYXBlcnMAABAACAAAyuv8UAAAABEACAAAzWyC5AAAAAEAEAE4jZwBOIyrATgm0wAAwEMAAgBATWFjaW50b3NoIEhEOlVzZXJzOgBwYXVsOgBEcm9wYm94OgByZXNlYXJjaF9wYXBlcnM6ADA0MDUyNTg0LnBkZgAOABoADAAwADQAMAA1ADIANQA4ADQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAC9Vc2Vycy9wYXVsL0Ryb3Bib3gvcmVzZWFyY2hfcGFwZXJzLzA0MDUyNTg0LnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJeAmACZQJwAnkChwKLApICmwKgAq0CsALCAsUCygAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM}}

@article{Canfora20071317,
	Abstract = {Pair programming has attracted an increasing interest from practitioners and researchers: there is initial empirical evidence that it has positive effects on quality and overall delivery time, as demonstrated by several controlled experiments. The practice does not only regard coding, since it can be applied to any other phase of the software process: analysis, design, and testing. Because of the asymmetry between design and coding, applying pair programming to the design phase might not produce the same benefits as those it produces in the development phase. In this paper, we report the findings of a controlled experiment on pair programming, applied to the design phase and performed in a software company. The results of the experiment suggest that pair programming slows down the task, yet improves quality. Furthermore we compare our results with those of a previous exploratory experiment involving students, and we demonstrate how the outcomes exhibit very similar trends. },
	Author = {Gerardo Canfora and Aniello Cimitile and Felix Garcia and Mario Piattini and Corrado Aaron Visaggio},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {http://dx.doi.org/10.1016/j.jss.2006.11.004},
	Issn = {0164-1212},
	Journal = {Journal of Systems and Software},
	Keywords = {Empirical studies},
	Note = {<ce:title>The Impact of Barry Boehm's Work on Software Engineering Education and Training</ce:title>},
	Number = {8},
	Pages = {1317 - 1327},
	Title = {Evaluating performances of pair designing in industry},
	Url = {http://www.sciencedirect.com/science/article/pii/S0164121206003414},
	Volume = {80},
	Year = {2007},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S0164121206003414},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.jss.2006.11.004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKS4uLy4uL3Jlc2VhcmNoX3BhcGVycy8xMC4xLjEuMTAxLjkyMTIucGRm0hcLGBlXTlMuZGF0YU8RAbYAAAAAAbYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMrrtgBIKwAAATiNnBMxMC4xLjEuMTAxLjkyMTIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVTVZzh2SUAAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAPcmVzZWFyY2hfcGFwZXJzAAAQAAgAAMrr/FAAAAARAAgAAM4dypAAAAABABABOI2cATiMqwE4JtMAAMBDAAIAR01hY2ludG9zaCBIRDpVc2VyczoAcGF1bDoARHJvcGJveDoAcmVzZWFyY2hfcGFwZXJzOgAxMC4xLjEuMTAxLjkyMTIucGRmAAAOACgAEwAxADAALgAxAC4AMQAuADEAMAAxAC4AOQAyADEAMgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANlVzZXJzL3BhdWwvRHJvcGJveC9yZXNlYXJjaF9wYXBlcnMvMTAuMS4xLjEwMS45MjEyLnBkZgATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALoAvwDHAoECgwKIApMCnAKqAq4CtQK+AsMC0ALTAuUC6ALtAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@article{Mendes:2005:IPN:1151954.1067526,
	Abstract = {This paper presents the results of a pair programming experiment conducted at the University of Auckland (NZ) during the first semester of 2004. It involved 300 second year Computer Science students attending a software design and construction course. We investigated similar issues to those reported in [26] and employed a subset of the questionnaires used by Laurie Williams et al. on the experiments presented in [26]. Our results support the use of pair programming as an effective programming/design learning technique.},
	Acmid = {1067526},
	Address = {New York, NY, USA},
	Author = {Mendes, Emilia and Al-Fakhri, Lubna Basil and Luxton-Reilly, Andrew},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1145/1151954.1067526},
	Issn = {0097-8418},
	Issue_Date = {September 2005},
	Journal = {SIGCSE Bull.},
	Keywords = {CS2, collaboration, pair programming, software design},
	Month = jun,
	Number = {3},
	Numpages = {5},
	Pages = {296--300},
	Publisher = {ACM},
	Title = {Investigating pair-programming in a 2nd-year software development and design computer science course},
	Url = {http://doi.acm.org/10.1145/1151954.1067526},
	Volume = {37},
	Year = {2005},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1151954.1067526},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1151954.1067526},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJS4uLy4uL3Jlc2VhcmNoX3BhcGVycy9wMjk2LW1lbmRlcy5wZGbSFwsYGVdOUy5kYXRhTxEBpgAAAAABpgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAyuu2AEgrAAABOI2cD3AyOTYtbWVuZGVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE50EPNbEVwAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAA9yZXNlYXJjaF9wYXBlcnMAABAACAAAyuv8UAAAABEACAAAzWx9sAAAAAEAEAE4jZwBOIyrATgm0wAAwEMAAgBDTWFjaW50b3NoIEhEOlVzZXJzOgBwYXVsOgBEcm9wYm94OgByZXNlYXJjaF9wYXBlcnM6AHAyOTYtbWVuZGVzLnBkZgAADgAgAA8AcAAyADkANgAtAG0AZQBuAGQAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAyVXNlcnMvcGF1bC9Ecm9wYm94L3Jlc2VhcmNoX3BhcGVycy9wMjk2LW1lbmRlcy5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC2ALsAwwJtAm8CdAJ/AogClgKaAqECqgKvArwCvwLRAtQC2QAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALb}}

@inproceedings{Begel:2008:PPW:1414004.1414026,
	Abstract = {Pair programming is a practice in which two programmers work collaboratively at one computer on the same design, algorithm, or code. Prior research on pair programming has primarily focused on its evaluation in academic settings. There has been limited evidence on the use, problems and benefits, partner selection, and the general perceptions towards pair programming in industrial settings. In this paper we report on a longitudinal evaluation of pair programming at Microsoft Corporation. We find from the results of a survey sent to a randomly selected 10% of engineers at Microsoft that 22% pair program or have pair programmed in the past. Using qualitative analysis, we performed a large-scale card sort to group the various benefits and problems of pair programming. The biggest perceived benefits of pair programming were the introduction of fewer bugs, spreading code understanding, and producing overall higher quality code. The top problems were cost-efficiency, (work time) scheduling problems, and personality conflicts. Most engineers preferred a partner who had complementary skills to their own, who was flexible and had good communication skills.},
	Acmid = {1414026},
	Address = {New York, NY, USA},
	Author = {Begel, Andrew and Nagappan, Nachiappan},
	Booktitle = {Proceedings of the Second ACM-IEEE international symposium on Empirical software engineering and measurement},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1145/1414004.1414026},
	Isbn = {978-1-59593-971-5},
	Keywords = {developers, empirical studies, pair programming, survey experiments},
	Location = {Kaiserslautern, Germany},
	Numpages = {9},
	Pages = {120--128},
	Publisher = {ACM},
	Series = {ESEM '08},
	Title = {Pair programming: what's in it for me?},
	Url = {http://doi.acm.org/10.1145/1414004.1414026},
	Year = {2008},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1414004.1414026},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1414004.1414026},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJC4uLy4uL3Jlc2VhcmNoX3BhcGVycy9wMTIwLWJlZ2VsLnBkZtIXCxgZV05TLmRhdGFPEQGiAAAAAAGiAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADK67YASCsAAAE4jZwOcDEyMC1iZWdlbC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATnQ+81sLvsAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAAD3Jlc2VhcmNoX3BhcGVycwAAEAAIAADK6/xQAAAAEQAIAADNbGc7AAAAAQAQATiNnAE4jKsBOCbTAADAQwACAEJNYWNpbnRvc2ggSEQ6VXNlcnM6AHBhdWw6AERyb3Bib3g6AHJlc2VhcmNoX3BhcGVyczoAcDEyMC1iZWdlbC5wZGYADgAeAA4AcAAxADIAMAAtAGIAZQBnAGUAbAAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAMVVzZXJzL3BhdWwvRHJvcGJveC9yZXNlYXJjaF9wYXBlcnMvcDEyMC1iZWdlbC5wZGYAABMAAS8AABUAAgAL//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AtQC6AMICaAJqAm8CegKDApEClQKcAqUCqgK3AroCzALPAtQAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAC1g==}}

@article{854064,
	Abstract = {The software industry has practiced pair programming (two programmers working side by side at one computer on the same problem) with great success for years, but people who haven't tried it often reject the idea as a waste of resources. The authors demonstrate that using pair programming in the software development process yields better products in less time-and happier, more confident programmers},
	Author = {Williams, L. and Kessler, R.R. and Cunningham, W. and Jeffries, Ron},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1109/52.854064},
	Issn = {0740-7459},
	Journal = {Software, IEEE},
	Keywords = {human resource management;programming;software development management;software quality;pair programming;production time;programmer confidence;resource utilization;software development process;software industry;software product quality;Algorithm design and analysis;Computer aided software engineering;Computer bugs;Computer industry;Mice;Organisms;Problem-solving;Programming profession;Software engineering;Switches},
	Number = {4},
	Pages = {19-25},
	Title = {Strengthening the case for pair programming},
	Volume = {17},
	Year = {2000},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/52.854064},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QIi4uLy4uL3Jlc2VhcmNoX3BhcGVycy8wMDg1NDA2NC5wZGbSFwsYGVdOUy5kYXRhTxEBmgAAAAABmgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAyuu2AEgrAAABOI2cDDAwODU0MDY0LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5z1PNbEsUAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAA9yZXNlYXJjaF9wYXBlcnMAABAACAAAyuv8UAAAABEACAAAzWyDVAAAAAEAEAE4jZwBOIyrATgm0wAAwEMAAgBATWFjaW50b3NoIEhEOlVzZXJzOgBwYXVsOgBEcm9wYm94OgByZXNlYXJjaF9wYXBlcnM6ADAwODU0MDY0LnBkZgAOABoADAAwADAAOAA1ADQAMAA2ADQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAC9Vc2Vycy9wYXVsL0Ryb3Bib3gvcmVzZWFyY2hfcGFwZXJzLzAwODU0MDY0LnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCzALgAwAJeAmACZQJwAnkChwKLApICmwKgAq0CsALCAsUCygAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALM}}

@article{Nierstrasz:1988:TMC:67387.67436,
	Abstract = {We propose two models of concurrent objects that address, respectively, methodological and semantic issues of object-oriented programming languages. The first is a conceptual model to aid in the design of object-oriented languages for concurrent and distributed applications, and the second is a computational model that can be used to define the semantics of such languages. The second model has evolved, in a sense, from the first, though it is intended to be both more neutral and more general. Traditional approaches to concurrency can be divided into two camps: those that view the world in terms of synchronized accesses to shared memory, and those that view everything in terms of message passing. A pure, shared memory view is inappropriate for object-oriented languages, since it separates data from the processes that manipulate them. Once we add data abstraction to the shared memory view, however, the differences between the two camps begin to cloud over. The remaining difference is between the kinds of ``objects'' that are passive or active. We propose a unifying model consisting of processes and threads. Processes have a state, and may be either active (changing state) or dormant. Threads are virtual, and simply indicate which processes are active. There is at most one thread in a given process at any time. Threads may move from one process to another if the latter process is dormant. A thread that is not in any process is suspended. The total amount of concurrent activity in a system at any time is thus defined by the total number of threads actually in processes, that is, the number of active processes. Each thread originates in some process that ``owns'' it. We can then distinguish between passive ``server'' processes without their own threads, and autonomous processes that own one or more threads. We can now use these notions of processes and threads as a reference model for describing the view of concurrency in the object model of a particular language or system. For example, we can distinguish passive and active objects by whether they have their own threads or not. We can also identify the granularity of concurrency by the correspondence between objects and processes. Typically ``top-level'' objects will map to processes, and sub-objects will map to part of the state of a process, but we may also consider objects with internal concurrency that correspond to systems of processes. The differences between various shared memory models and message-passing models can be understood in terms of the policies which determine when a thread may enter a process (i.e., locks, waits and signals, synchronous or asynchronous message-passing, etc.). We have designed and implemented a concurrent object-oriented language called Hybrid, based on this model, in which an object is either a process, or is inside a process, as part of another object [Nierstrasz 1987; Konstantas, et al. 1988]. [Nier87c] [Konst88] Objects communicate with one another by invoking operations and responding to invocations in a remote procedure call fashion. The trace of call/return communications corresponds to a thread. We can understand communication between objects in different processes in terms of the policy for admitting a thread. Threads are suspended on a queue (effectively a message queue) if the target is either busy, or blocked on a call of its own. This basic policy can be modified through the use of two language constructs, delay queues and delegation. A delay queue enables a process to selectively delay threads attempting to invoke certain operations. Delegation in Hybrid is a mechanism that enables a process to switch between threads by not blocking when calling an object in another process. Two other constructs, one for managing hierarchies of threads, and another for managing transactions, were designed, but not implemented. Although the language design adopted a message-passing communication model, the prototype implementation modeled threads as lightweight processes, and processes as shared, passive entities. The point is that the conceptual model of processes and threads made it fairly easy to propose and design communication and synchronization primitives consistent with a concurrent object-oriented paradigm, independently of the implementation strategy. Although this model is useful as a framework for understanding concurrent objects and for designing language constructs, it is inadequate as a computational model. In particular, it says nothing about either the ``state'' of a process, or the events that cause it to change state. We see the need for a computational model that will be useful: begin {itemize} item for defining the semantics of concurrent, object-oriented languages like Hybrid, item for comparing mechanisms of various languages and their implementation environments, item and for aiding language designers by providing a basis for language definition tools. end {itemize} We propose a new computational model that combines ideas from CCS [Milner 1980] and Actors [Agha 1986]. [Miln80] [Agha86] Our motivation for a new approach is based on the following positions: begin {enumerate} item Concurrency cannot be modeled by non-determinism. item Programs are not functions. end {enumerate} The first statement means that we reject approaches that attempt to interpret concurrency by an interleaving semantics. Instead, events in a concurrent computation should be seen as being partially ordered. We believe there is an important difference between multiple observers seeing different orders of events in a truly concurrent computation, and a mono-processor non-deterministically selecting a particular total (i.e., serialized) order on the events of a pseudo-concurrent computation. The second statement expresses the conviction that standard views of programs as functions from inputs to outputs, not only discriminate against object-oriented languages by separating program from data, but they are poor at capturing concurrent computations built up of systems of cooperating programs. Instead, we believe that computation, especially concurrent computation, can be better modeled in terms of communicating systems of concurrent agents. Rather than distinguishing between the finite control and the ``input'' to a computation, we model them together as an initial system of concurrent agents (i.e., processes, or ``objects''). The progress of a computation can be observed as a partial order of events, where each event represents a (synchronous) communication between a pair of agents, and yields a new, possibly concurrent, behaviour for each of the participants of the event. The ``output'' of a partial computation is a new system of agents, which may then continue to participate in events, if any are possible. Computations may or may not terminate. We have designed and implemented a simple CCS-like language called Abacus based on a subset of these ideas [Nierstrasz 1988]. [Nier88d] Agents are specified using behaviour expressions which encapsulate the events (communications) the agent may participate in. Behaviour expressions consist of input and output offers (i.e., guards) on event names. Operators on behaviour expressions include non-deterministic choice and concurrent composition. A behaviour expression for a system of agents is a static description of possible computations that may result. Events may take place when there are matching offers between concurrently composed agents. The resulting partial order of events is effectively a history of the computation for multiple observers. Any initial sequence of observed events yields a new behaviour expression that describes the remaining possible computations. The current version of Abacus has only the power of finite automata (there is a finite set of reachable states for any system). We are presently searching for the right set of primitives that will extend Abacus to be computationally complete, yet permit behaviour expressions to remain directly interpretable. Our long term goal is to use Abacus as a tool for defining the semantics of languages like Hybrid, and for providing a formal and implementable basis for studying and comparing constructs of concurrent and object-oriented programming languages. [Agha 1986] G.A. Agha, ACTORS: A Model of Concurrent Computation in Distributed Systems, The MIT Press, Cambridge, Massachusetts, 1986. [Konstantas, et al. 1988] D. Konstantas, O.M. Nierstrasz and M. Papathomas, ``An Implementation of Hybrid, a Concurrent Object-Oriented Language'', in Active Object Environments, ed. D.C. Tsichritzis, Centre Universitaire d'Informatique, University of Geneva, June 1988. [Milner 1980] R. Milner, A Calculus of Communicating Systems, Lecture Notes in Computer Science 92, Springer-Verlag, 1980. [Nierstrasz 1987] O.M. Nierstrasz, ``Active Objects in Hybrid'', ACM SIGPLAN Notices, Proceedings OOPSLA '87, vol. 22, no. 12, pp. 243-253, Dec. 1987. [Nierstrasz 1988] O. Nierstrasz, ``Mapping Object Descriptions to Behaviours'', in Active Object Environments, ed. D.C. Tsichritzis, Centre Universitaire d'Informatique, University of Geneva, June 1988.
},
	Acmid = {67436},
	Address = {New York, NY, USA},
	Author = {Nierstrasz, O. M.},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Issn = {0362-1340},
	Issue = {4},
	Journal = {SIGPLAN Not.},
	Month = {September},
	Numpages = {3},
	Pages = {174--176},
	Publisher = {ACM},
	Title = {Two models of concurrent objects},
	Volume = {24},
	Year = {1988},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKS4uLy4uL3Jlc2VhcmNoX3BhcGVycy9wMTc0LW5pZXJzdHJhc3oucGRm0hcLGBlXTlMuZGF0YU8RAbYAAAAAAbYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMrrtgBIKwAAATiNnBNwMTc0LW5pZXJzdHJhc3oucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUfKgycpZMQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAPcmVzZWFyY2hfcGFwZXJzAAAQAAgAAMrr/FAAAAARAAgAAMnKkXEAAAABABABOI2cATiMqwE4JtMAAMBDAAIAR01hY2ludG9zaCBIRDpVc2VyczoAcGF1bDoARHJvcGJveDoAcmVzZWFyY2hfcGFwZXJzOgBwMTc0LW5pZXJzdHJhc3oucGRmAAAOACgAEwBwADEANwA0AC0AbgBpAGUAcgBzAHQAcgBhAHMAegAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANlVzZXJzL3BhdWwvRHJvcGJveC9yZXNlYXJjaF9wYXBlcnMvcDE3NC1uaWVyc3RyYXN6LnBkZgATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALoAvwDHAoECgwKIApMCnAKqAq4CtQK+AsMC0ALTAuUC6ALtAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/67387.67436}}

@inproceedings{6227110,
	Abstract = {Pair Programming is one of the most studied and debated development techniques. However, at present, we do not have a clear, objective, and quantitative understanding of the claimed benefits of such development approach. All the available studies focus on the analysis of the effects of Pair Programming (e.g., code quality, development speed, etc.) with different findings and limited replicability of the experiments. This paper adopts a different approach that could be replicated in an easier way: it investigates how Pair Programming affects the way developers write code and interact with their development machine. In particular, the paper focuses on the effects that Pair Programming has on developers' attention and productivity. The study was performed on a professional development team observed for ten months and it finds out that Pair Programming helps developers to eliminate distracting activities and to focus on productive activities.},
	Author = {Sillitti, A. and Succi, G. and Vlasenko, J.},
	Booktitle = {Software Engineering (ICSE), 2012 34th International Conference on},
	Date-Added = {2013-07-30 20:00:52 +0000},
	Date-Modified = {2013-07-30 20:00:52 +0000},
	Doi = {10.1109/ICSE.2012.6227110},
	Issn = {0270-5257},
	Keywords = {software prototyping;agile software development;case study;debated development techniques;developers attention;development machine;large industrial experimentation;pair programming;quantitative understanding;Browsers;PROM;Productivity;Programming profession;Switches;Visualization;Software development process;pair programming;productivity},
	Pages = {1094-1101},
	Title = {Understanding the impact of Pair Programming on developers attention: A case study on a large industrial experimentation},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/ICSE.2012.6227110},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLC4uLy4uL3Jlc2VhcmNoX3BhcGVycy9wMTA5NC0yNDAtc2lsbGl0dGkucGRm0hcLGBlXTlMuZGF0YU8RAcIAAAAAAcIAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAMrrtgBIKwAAATiNnBZwMTA5NC0yNDAtc2lsbGl0dGkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOdFjzZrvVVBERiAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAPcmVzZWFyY2hfcGFwZXJzAAAQAAgAAMrr/FAAAAARAAgAAM2bJ5UAAAABABABOI2cATiMqwE4JtMAAMBDAAIASk1hY2ludG9zaCBIRDpVc2VyczoAcGF1bDoARHJvcGJveDoAcmVzZWFyY2hfcGFwZXJzOgBwMTA5NC0yNDAtc2lsbGl0dGkucGRmAA4ALgAWAHAAMQAwADkANAAtADIANAAwAC0AcwBpAGwAbABpAHQAdABpAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgA5VXNlcnMvcGF1bC9Ecm9wYm94L3Jlc2VhcmNoX3BhcGVycy9wMTA5NC0yNDAtc2lsbGl0dGkucGRmAAATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAL0AwgDKApACkgKXAqICqwK5Ar0CxALNAtIC3wLiAvQC9wL8AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAv4=}}
